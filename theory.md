`@Composable` - аннотация, которая сообщает компилятору, что функция участвует в рисования пользовательского интерфейса.

```
Text(buildAnnotatedString {}) // позволяет создавать подобие RichText
withStyle(style) {
    append("text")
}
```

FillBounds - изображение растягивается до границ
FillHeight - занять всё место по высоте, изображение не растягивается, а обрезается по ширине
FillWidth - занять всё место по ширине, изображение не растягивается, а обрезается по высоте

Modifiers вызываются по очереди.
Порядок modifiers имеет значение.
Одни и те же Modifiers могут быть вызваны несколько раз.

Если Composable функция зависит от значения из MutableState, то при изменении State функция будет вызвана ещё раз, то
есть, произойдёт перерисовка. Чтобы значения сохранялись между перерисовками, оно должно быть обёрнуто в
функцию remember. Остальное дерево не перерисовывается.

Чтобы добавить SnackBar, нужно добавить SnackBarHost и управлять им через его state.
rememberCoroutineScope() предоставляет scope внутри composable функций, который выживает между рекомпозициями.
То есть при рекомпозиции корутины не отменяются.

remember переживает рекомпозицию, но не переживает смену конфигурации устройства(переворот экрана). rememberSaveable
переживает.

Использование делегатов может создавать рекомпозиции тех функций, которые не должны перестраиваться, если мы считываем
state и передаём дальше его по дереву. Лучше передать State и уже на месте извлекать value.

Чтобы восстанавливать state при навигации назад, нужно использовать rememberSaveable на восстанавливаемом экране.

```kotlin
if (item.screen.route != current) { // не позволяем рекомпозицию при нажатии на тот же самый элемент
    navController.navigate(item.screen.route) {
        popUpTo(BottomNavigationItem.HOME.screen.route) { // удаляем всё до определенного экрана
            saveState = true // сохраняем состояние удаляемых экранов
        }
        restoreState = true // восстанавливаем state удалённого экрана
    }
}
```

Uri.encode() позволяет передать строку содержащие спецсимволы в навигацию.

Можно создать свой NavType, но игра не стоит свеч, проще строку перекидывать и (де)сериализовать.

С помощью ActivityForResultApi можно получать разрешения, например. Есть встроенные контракты.
ActivityForResultApi - это контракт.

Функции внутри composable функций не исполняются последовательно, поэтому вызов не composable функций лучше избегать и
не рассчитывать на последовательность выполнения.

SideEffect {} - вызывается после каждой рекомпозиции функции.
LaunchedEffect {} - вызывается при первой композиции и изменении ключа. Также, не переживает смену конфигурации.

