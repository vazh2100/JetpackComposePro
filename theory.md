`@Composable` - аннотация, которая сообщает компилятору, что функция участвует в рисования пользовательского интерфейса.

```
Text(buildAnnotatedString {}) // позволяет создавать подобие RichText
withStyle(style) {
    append("text")
}
```

FillBounds - изображение растягивается до границ
FillHeight - занять всё место по высоте, изображение не растягивается, а обрезается по ширине
FillWidth - занять всё место по ширине, изображение не растягивается, а обрезается по высоте

Modifiers вызываются по очереди.
Порядок modifiers имеет значение.
Одни и те же Modifiers могут быть вызваны несколько раз.

Если Composable функция зависит от значения из MutableState, то при изменении State функция будет вызвана ещё раз, то
есть, произойдёт перерисовка. Чтобы значения сохранялись между перерисовками, оно должно быть обёрнуто в
функцию remember. Остальное дерево не перерисовывается.

Чтобы добавить SnackBar, нужно добавить SnackBarHost и управлять им через его state.
rememberCoroutineScope() предоставляет scope внутри composable функций, который выживает между рекомпозициями.
То есть при рекомпозиции корутины не отменяются.

remember переживает рекомпозицию, но не переживает смену конфигурации устройства(переворот экрана). rememberSaveable
переживает.

Использование делегатов может создавать рекомпозиции тех функций, которые не должны перестраиваться, если мы считываем
state и передаём дальше его по дереву. Лучше передать State и уже на месте извлекать value.

Чтобы восстанавливать state при навигации назад, нужно использовать rememberSaveable на восстанавливаемом экране.

```kotlin
if (item.screen.route != current) { // не позволяем рекомпозицию при нажатии на тот же самый элемент
    navController.navigate(item.screen.route) {
        popUpTo(BottomNavigationItem.HOME.screen.route) { // удаляем всё до определенного экрана
            saveState = true // сохраняем состояние удаляемых экранов
        }
        restoreState = true // восстанавливаем state удалённого экрана
    }
}
```

Uri.encode() позволяет передать строку содержащие спецсимволы в навигацию.

Можно создать свой NavType, но игра не стоит свеч, проще строку перекидывать и (де)сериализовать.

С помощью ActivityForResultApi можно получать разрешения, например. Есть встроенные контракты.
ActivityForResultApi - это контракт.

Функции внутри composable функций не исполняются последовательно, поэтому вызов не composable функций лучше избегать и
не рассчитывать на последовательность выполнения.

Effect API:
1) SideEffect {} - вызывается после каждой рекомпозиции.
2) LaunchedEffect(key) {} - вызывается при первой композиции и изменении ключа. Также, не переживает смену конфигурации.
3) rememberUpdatedState(value) - применяется в паре с LaunchedEffect, если во время исполнения переживает рекомпозиции.
   В момент обращения из LaunchedEffect к этой переменной, LaunchedEffect получит самое новое значение.
4) DisposableEffect(key){} = LaunchedEffect + onDispose(). Если нужно выполнять действие, и потом, когда composable
   функция покинет дерево или когда поменяется ключ очистить ресурсы в onDispose.
5) produceState(initialValue, keys) - похож на flow c мгновенным запуском. Создаёт state и обновляет его изнутри.
6) shapshotFlow{ state.value } (внутри LaunchedEffect) - создаёт Flow, отслеживает значение стейта и эмитит его в Flow

Можно преобразовать Flow в LiveData.

viewModel работает когда приложение свёрнуто, поэтому лучше в onResume и в OnPause управлять обновлениями.
asLiveData автоматически отслеживает сворачивание экрана и через определённое время прекращает подписку.
Также переживает смену конфигурации. В общем, полезно.
в случае с compose можно использовать collectWithLifeCycle()

позволяет автоматически отслеживать минимальное состояние для запуска и отмены.
```kotlin
lifeCycleScope.launch {
   repeatOnLifeCycle(Resumed) {
      //
   }
}

flow.flowWithLifeCycle() // делает то же самое
```

Можно внутри холодного flow подписаться на горячий и класть в горячий flow. Таким образом холодный flow не закончит свою
работу и в него можно класть значения снаружи.

flow{}.buffer() - создаёт буфер и продюсер не ждёт коллектора
flow{}.collectLatest {} - прерывает сбор текущего элемента, если выпущен новый // аналогично mapLatest, transformLatest

Ловить исключения в блоке flow { } нельзя, это нарушает принцип прозрачности исключений. Все ошибки должны доходить до
коллектора. в блоке catch можно выпустить другое значение, если нужно, чтобы flow не прерывал работу. Или выпустить
state Error. retry пишется перед catch.

`@Immutable` data class - даёт понять compose, что data class 100% неизменяемый. Таким образом, если composable функция
будет вызвана с тем же самым объектом(равен по equals) в качестве параметра, то её рекомпозиция не будет происходить.
Это актуально для виджета управляющего навигацией.
Эта аннотация говорит, что этот объект не будет изменён никогда, поэтому изменение var и списков игнорируется.

animationSpec = tween(durationMillis = 3000, delayMillis = 0, easing = LinearEasing)
animationSpec = spring() - анимация-пружина
animationSpec = infiniteRepeatable( animation = tween(1500), repeatMode = RepeatMode.Reverse, initialStartOffset =
StartOffset(1000)),
val transition = rememberInfiniteTransition();
val color2 by transition.animateColor(